#!/usr/bin/env stack runghc

-- a more advanced example of State Monad

import Control.Monad (liftM, ap)

-- programming haskell P170
-- 
data Tree a = Leaf a 
            | Node (Tree a) (Tree a)
            deriving (Show)

tree :: Tree Char
tree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')

-- P171
-- consider the problem of defining a function that relabels
-- each leaf in such a tree with a unique or fresh integer.
-- using the type of state transformer by Tree a -> ST (Tree Int),
-- where the state is the next fresh integer. The next such int
-- can be generated by defining a state transformer that simply
-- returns the current state as its result and the next int
-- as the new state
type S = Int

newtype ST a = ST (S -> (a, S))
app :: ST a -> S -> (a, S)
app (ST st) s = st s

instance Functor ST where
  fmap = liftM

instance Applicative ST where
  pure = return
  (<*>) = ap

instance Monad ST where
  return x = ST (\s -> (x, s))
  sta >>= f = 
    ST $ \s ->
      let (x, s') = app sta s
      in app (f x) s'

-- Question:
-- How is the new label tree generated here ??

-- MY NOTES: review ST (StateTransformer)'s functor definition
-- HINTS:

-- Leaf <$> St is really fmap g st, where Leaf (the data ctor)
-- is the function g; same applies for Node (another data ctor)
-- where it recurs into the L and R children;

-- fmap here yields the new Leaf in the form of ((Leaf x), s);
-- for the second form, the recursion, fmap yields 
-- ((Node (Leaf x) (Leaf x + 1)), s)
alabel :: Tree a -> ST (Tree Int)
--                  ^^^^^^^^^^^^^ remember the wrapped value
alabel (Leaf _) = 
--      ^^^^^^ value of the Leaf node is not used
  Leaf <$> (ST $ \s -> (s, s + 1)) -- rename n to s for clarity
  --             ^^ only state is used to compute new leaf
alabel (Node l r) = Node <$> alabel l <*> alabel r

-- MY NOTE:
-- this is my experiment of a more complex label tree that encapsulates
-- strings; note that it uses both the Leaf value and the state
-- to produce this new Leaf node
slabel :: (Show a) => Tree a -> ST (Tree String)
--                                 ^^^^^^^^^^^^^ remember the wrapped value
slabel (Leaf v) =
  --   ^^^^^^^ leaf value is used to compute new leaf
  Leaf <$> (ST $ \s -> (show v ++ "-" ++ show s, s + 1))
  --             ^^ state is also used to compute new leaf
slabel (Node l r) = Node <$> slabel l <*> slabel r

-- programming haskell P172
-- using the fact that ST is also a monad,. we can define an 
-- equivalent monadic version of the relabelling function using
-- the do notation
mlabel :: Tree a -> ST (Tree Int)
mlabel (Leaf v) = do
  n <- ST (\s -> (s, s + 1))
  return (Leaf n)
mlabel (Node l r) = do
  l' <- mlabel l
  r' <- mlabel r
  return (Node l' r')

demoTreeNodes :: IO ()
demoTreeNodes = do
  print
    "//////// demo create tree nodes //////////////////////////"
  print $ (Leaf 2 :: Tree Int)
  print $ tree
  -- Tree a is not a functor therefore I CAN NOT do the following
  -- print $ id <$> tree
  -- in constrast:
  -- print $ id <$> [1, 2]
  -- list is a functor

demoALabel :: IO ()
demoALabel = do
  print
    "//////// demo alabel /////////////////////////////////////"
  print $ fst (app (alabel (Leaf "thereis" :: Tree String)) 11)
  print $ fst (app (alabel tree) 101)

demoSLabel :: IO ()
demoSLabel = do
  print
    "//////// demo slabel /////////////////////////////////////"
  print $ fst (app (slabel (Leaf "thereis" :: Tree String)) 0)
  print $ fst (app (slabel tree) 0)

demoMLabel :: IO ()
demoMLabel = do
  print
    "//////// demo mlabel /////////////////////////////////////"
  print $ fst (app (mlabel (Leaf "thereis" :: Tree String)) 1001)
  print $ fst (app (mlabel tree) 2001)

main :: IO ()
main = do
  demoTreeNodes
  demoALabel
  demoSLabel
  demoMLabel
